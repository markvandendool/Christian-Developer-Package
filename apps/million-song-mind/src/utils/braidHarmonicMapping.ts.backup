// Braid to Harmonic Profile mapping system
// Maps braid positions to harmonic profile slots based on Roman numeral analysis

import { CHORD_SLOTS } from '@/constants/harmony';
import { noteToRoman } from '@/utils/chordMapping';

// Verbose logging utility
const VERBOSE_LOGGING = true; // Set to false to disable
const log = (message: string, data?: any) => {
  if (VERBOSE_LOGGING) {
    const timestamp = new Date().toISOString();
    const logMessage = `[${timestamp}] üéµ BRAID_MAPPING: ${message}`;
    console.log(logMessage, data ? data : '');
    
    // Also log to a global array for debugging
    if (typeof window !== 'undefined') {
      if (!window.braidMappingLogs) {
        window.braidMappingLogs = [];
      }
      window.braidMappingLogs.push({ timestamp, message, data });
    }
  }
};

/**
 * Map Roman numeral chord to harmonic profile slot based on the rules:
 * - I, ii, iii, vi, vii√∏, I7 are 1:1 unique mappings
 * - V and V(b7) map to the same harmonic profile slot (V)
 * - II, III, V, VI, VII have multiple braid positions but map to single harmonic profile slots
 * - IV7 maps to "Other"
 * - Diminished symbols are flexible except vii√∏/vii¬∫ which must be unique
 */
export function mapRomanToHarmonicSlot(chord: string, key: string = 'C'): string | null {
  log(`üîç MAPPING REQUEST: chord="${chord}", key="${key}"`);
  
  if (!chord || chord.trim() === '') {
    log(`‚ùå EMPTY CHORD: returning null`);
    return null;
  }

  const cleanChord = chord.trim();
  log(` CLEANED CHORD: "${cleanChord}"`);

  // Handle note names first (from braid clicks like "Am", "C", "F#", etc.)
  // Convert note names to Roman numerals using key context
  const notePattern = /^([A-G][#b]?)m?$/;
  const noteMatch = cleanChord.match(notePattern);
  if (noteMatch) {
    log(` NOTE NAME DETECTED: "${cleanChord}" matches note pattern`);
    const romanNumeral = noteToRoman(cleanChord, key);
    log(` NOTE TO ROMAN: "${cleanChord}" ‚Üí "${romanNumeral}" in key "${key}"`);
    if (romanNumeral) {
      log(`‚úÖ RECURSIVE MAPPING: calling mapRomanToHarmonicSlot("${romanNumeral}", "${key}")`);
      return mapRomanToHarmonicSlot(romanNumeral, key);
    } else {
      log(`‚ùå NOTE TO ROMAN FAILED: "${cleanChord}" could not be converted to Roman numeral in key "${key}"`);
      return null;
    }
  }
  
  log(`üìù ROMAN NUMERAL DETECTED: "${cleanChord}" - checking mappings`);
  
  // Handle exact matches for unique 1:1 mappings
  const uniqueMappings: Record<string, string> = {
    'I': 'I',
    'ii': 'ii', 
    'iii': 'iii',
    'vi': 'vi',
    'vii√∏': 'vii√∏',
    'I7': 'I7',
    'vii¬∫': 'vii√∏', // Maps to same slot as vii√∏ per rules
  };

  if (uniqueMappings[cleanChord]) {
    log(`‚úÖ UNIQUE MAPPING: "${cleanChord}" ‚Üí "${uniqueMappings[cleanChord]}"`);
    return uniqueMappings[cleanChord];
  }

  // Handle applied chords that map to "Other"
  if (cleanChord === 'IV7') {
    log(`üîÑ SPECIAL CASE: "${cleanChord}" ‚Üí "Other"`);
    return 'Other';
  }

  // Handle many-to-one mappings (with and without ‚ô≠7)
  const manyToOneMappings: Record<string, string> = {
    // V and V(‚ô≠7) map to same slot
    'V': 'V',
    'V7': 'V',
    'V(b7)': 'V',
    'V(‚ô≠7)': 'V',
    'Vb7': 'V',
    
    // II variations map to same slot
    'II': 'II(7)',
    'II7': 'II(7)',
    'II(b7)': 'II(7)',
    'II(‚ô≠7)': 'II(7)',
    'IIb7': 'II(7)',
    
    // III variations map to same slot
    'III': 'III(7)',
    'III7': 'III(7)',
    'III(b7)': 'III(7)',
    'III(‚ô≠7)': 'III(7)',
    'IIIb7': 'III(7)',
    
    // VI variations map to same slot
    'VI': 'VI(7)',
    'VI7': 'VI(7)',
    'VI(b7)': 'VI(7)',
    'VI(‚ô≠7)': 'VI(7)',
    'VIb7': 'VI(7)',
    
    // VII variations map to same slot
    'VII': 'VII(7)',
    'VII7': 'VII(7)',
    'VII(b7)': 'VII(7)',
    'VII(‚ô≠7)': 'VII(7)',
    'VIIb7': 'VII(7)',
    // Minor bVII remains bVII bucket
    'bVII': 'bVII',
    'bVII7': 'bVII',
    'bVII(b7)': 'bVII',
    'bVII(‚ô≠7)': 'bVII',
    'bVIIb7': 'bVII',
  };

  if (manyToOneMappings[cleanChord]) {
    log(`üîÑ MANY-TO-ONE MAPPING: "${cleanChord}" ‚Üí "${manyToOneMappings[cleanChord]}"`);
    return manyToOneMappings[cleanChord];
  }

  // Handle diminished chords with flexible symbols (except vii√∏/vii¬∫ which are unique above)
  const diminishedPattern = /^([iv]+|[IV]+)([¬∫¬∞√∏])$/;
  const dimMatch = cleanChord.match(diminishedPattern);
  if (dimMatch) {
    const root = dimMatch[1];
    log(`üé≠ DIMINISHED DETECTED: "${cleanChord}" with root "${root}"`);
    // Map common diminished chords
    if (root.toLowerCase() === 'ii') {
      log(` DIMINISHED MAPPING: "${cleanChord}" ‚Üí "#iv√∏" (ii root)`);
      return '#iv√∏';
    }
    if (root.toLowerCase() === 'iv') {
      log(` DIMINISHED MAPPING: "${cleanChord}" ‚Üí "#iv√∏" (iv root)`);
      return '#iv√∏';
    }
    if (root.toLowerCase() === 'vi') {
      log(` DIMINISHED MAPPING: "${cleanChord}" ‚Üí "#iv√∏" (vi root)`);
      return '#iv√∏';
    }
  }

  // Handle case variations and flats/sharps
  const normalizedRoman = normalizeRomanNumeral(cleanChord);
  log(` NORMALIZATION: "${cleanChord}" ‚Üí "${normalizedRoman}"`);
  if (manyToOneMappings[normalizedRoman]) {
    log(`‚úÖ NORMALIZED MAPPING: "${cleanChord}" ‚Üí "${normalizedRoman}" ‚Üí "${manyToOneMappings[normalizedRoman]}"`);
    return manyToOneMappings[normalizedRoman];
  }

  // If no mapping found, return null (will be treated as "Other")
  log(`‚ùå NO MAPPING FOUND: "${cleanChord}" - returning null (will be treated as "Other")`);
  return null;
}

/**
 * Normalize Roman numeral notation for consistent mapping
 */
function normalizeRomanNumeral(roman: string): string {
  const normalized = roman
    .replace(/‚ô≠/g, 'b')
    .replace(/‚ôØ/g, '#')
    .replace(/¬∞/g, '¬∫')
    .replace(/√∏/g, '√∏');
  log(`üîÑ NORMALIZE: "${roman}" ‚Üí "${normalized}"`);
  return normalized;
}

/**
 * Get chord usage for a specific braid position based on harmonic function mapping
 * This replaces the simple chord name lookup with harmonic function mapping
 */
export function getBraidPositionUsage(
  romanLabel: string,
  harmonicUsageData: Record<string, number>,
  key: string = 'C'
): number {
  log(`üìä USAGE REQUEST: romanLabel="${romanLabel}", key="${key}"`);
  const harmonicSlot = mapRomanToHarmonicSlot(romanLabel, key);
  
  if (!harmonicSlot) {
    log(`‚ùå NO USAGE: "${romanLabel}" has no harmonic slot`);
    return 0;
  }
  
  const usage = harmonicUsageData[harmonicSlot] || 0;
  log(`üìä USAGE RESULT: "${romanLabel}" ‚Üí "${harmonicSlot}" ‚Üí ${usage}`);
  return usage;
}

/**
 * Create a mapping of all harmonic profile slots to their braid positions
 * This helps understand which braid positions correspond to each harmonic function
 */
export function createHarmonicSlotToBraidMapping(): Record<string, string[]> {
  const mapping: Record<string, string[]> = {};
  
  // Initialize all harmonic slots
  CHORD_SLOTS.forEach(slot => {
    mapping[slot] = [];
  });
  
  // Common Roman numerals that appear in the braid
  const commonRomanNumerals = [
    'I', 'ii', 'iii', 'IV', 'V', 'vi', 'vii√∏', 'I7',
    'II', 'II7', 'III', 'III7', 'VI', 'VI7', 'VII', 'VII7',
    'V7', 'IV7', 'bVII', 'bVII7', '#iv√∏', 'vii¬∫',
    // Add variations with different flat/sharp notations
    'bII', 'bIII', 'bV', 'bVI', '#I', '#II', '#IV', '#V', '#VI'
  ];
  
  commonRomanNumerals.forEach(roman => {
    const slot = mapRomanToHarmonicSlot(roman);
    if (slot && mapping[slot]) {
      mapping[slot].push(roman);
    }
  });
  
  return mapping;
}

/**
 * Debug function to validate mappings
 */
export function validateBraidHarmonicMapping(): {
  validMappings: Record<string, string>;
  unmappedRomans: string[];
} {
  const commonRomanNumerals = [
    'I', 'ii', 'iii', 'IV', 'V', 'vi', 'vii√∏', 'I7',
    'II', 'II7', 'III', 'III7', 'VI', 'VI7', 'VII', 'VII7',
    'V7', 'IV7', 'bVII', 'bVII7', '#iv√∏', 'vii¬∫'
  ];
  
  const validMappings: Record<string, string> = {};
  const unmappedRomans: string[] = [];
  
  commonRomanNumerals.forEach(roman => {
    const slot = mapRomanToHarmonicSlot(roman);
    if (slot) {
      validMappings[roman] = slot;
    } else {
      unmappedRomans.push(roman);
    }
  });
  
  return { validMappings, unmappedRomans };
}